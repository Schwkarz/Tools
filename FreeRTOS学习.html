<!DOCTYPE html><html><head>
      <title>FreeRTOS学习</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\30294\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.10\crossnote\dependencies\katex\katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="第一章">第一章 </h1>
<ul>
<li>pdTRUE == pdPASS == 1</li>
<li>pdFALSE == pdFAIL == 0</li>
</ul>
<h1 id="第三章">第三章 </h1>
<pre class="language-text">裸机系统与多任务系统
</pre>
<h2 id="1-裸机系统">1 裸机系统 </h2>
<h3 id="11-轮询系统">1.1 轮询系统 </h3>
<ul>
<li>初始化硬件</li>
<li>主程序在死循环中运行</li>
<li>需要检测外部信号时，实时响应能力不佳</li>
<li>只适合顺序执行的功能代码</li>
</ul>
<h3 id="12-前后台系统">1.2 前后台系统 </h3>
<ul>
<li>在轮询基础上加入了<em><strong>中断</strong></em></li>
<li>外部事件响应在中断中完成</li>
<li>中断 == 前台；main（）中无限循环 == 后台；</li>
</ul>
<h2 id="2多任务系统">2.多任务系统 </h2>
<ul>
<li>事件响应为中断。但在中断中如果出现<strong>更高优先级</strong>的中断，将会打断当前中断</li>
<li>事件处理在任务中进行，不用考虑每个功能模块之间的干扰，方便编程</li>
<li>系统会占据少量FLASH和RAM</li>
</ul>
<h1 id="第四章">第四章 </h1>
<pre class="language-text">数据结构——列表与列表项
</pre>
<p><strong>FreeRTOS中链表节点数据结构</strong></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">xLIST_ITEM</span>
<span class="token punctuation">{</span>
    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           
    configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span>          <span class="token comment">/* 用于辅助排序的值，当
#define configUSE_16_BIT_TICKS			0 当设置为0时，TickType_t表示32位 */</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">xLIST_ITEM</span> <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span>     <span class="token comment">//下一个节点</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">xLIST_ITEM</span> <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span> <span class="token comment">//上一个节点   </span>
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span> pvOwner<span class="token punctuation">;</span>                                     <span class="token comment">//指向该节点拥有者，在哪个数据结构中，属于哪个数据结构成员</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">xLIST</span> <span class="token operator">*</span> configLIST_VOLATILE pxContainer<span class="token punctuation">;</span>     <span class="token comment">//指向该节点所在链表，通常指向根节点</span>
    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          
<span class="token punctuation">}</span><span class="token punctuation">;</span>    
<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">xLIST_ITEM</span> ListItem_t<span class="token punctuation">;</span>                   <span class="token comment">/* For some reason lint wants this as two separate definitions. */</span>
</code></pre><pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> pxItem <span class="token punctuation">)</span> PRIVILEGED_FUNCTION<span class="token punctuation">;</span>    <span class="token comment">//链表节点初始化</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vListInitialise</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> pxList <span class="token punctuation">)</span> PRIVILEGED_FUNCTION<span class="token punctuation">;</span>            <span class="token comment">//链表根节点初始化</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vListInsertEnd</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> pxList<span class="token punctuation">,</span>
                     ListItem_t <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> pxNewListItem <span class="token punctuation">)</span> PRIVILEGED_FUNCTION<span class="token punctuation">;</span>  <span class="token comment">//将节点插入链表的尾部</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vListInsert</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> pxList<span class="token punctuation">,</span>
                  ListItem_t <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> pxNewListItem <span class="token punctuation">)</span> PRIVILEGED_FUNCTION<span class="token punctuation">;</span>     <span class="token comment">//将节点按照升序排列插入链表</span>
UBaseType_t <span class="token function">uxListRemove</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> pxItemToRemove <span class="token punctuation">)</span> PRIVILEGED_FUNCTION<span class="token punctuation">;</span>
                                                                              <span class="token comment">//将节点从链表中删除</span>

</code></pre><h1 id="第五章">第五章 </h1>
<pre class="language-text">任务的定义与任务切换
</pre>
<ul>
<li>每个任务互相独立、互不干扰</li>
<li>需要分配空间，预先定义好的全局数组（静态）或是动态分配的内存空间（动态）</li>
<li>任务启动调度器由</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><h3 id="前十章为内核讲解不在过多记笔记可以直接看书">前十章为内核讲解，不在过多记笔记，可以直接看书 </h3>
<h1 id="第十一章">第十一章 </h1>
<pre class="language-text">移植FreeRTOS到STM32
</pre>
<h3 id="1使用rm空工程作为裸机工程模板">1.使用RM空工程作为裸机工程模板 </h3>
<h3 id="2下载freertos源码">2.下载FreeRTOS源码 </h3>
<ul>
<li><a href="https://www.freertos.org/zh-cn-cmn-s/">https://www.freertos.org/zh-cn-cmn-s/</a></li>
</ul>
<h3 id="3将freertos源码复制到裸机工程中">3.将FreeRTOS源码复制到裸机工程中 </h3>
<ul>
<li><img src="image.png" alt="Alt text"></li>
<li><img src="image-1.png" alt="z"></li>
<li><img src="image-2.png" alt="Alt text"></li>
</ul>
<h3 id="4在keil中添加头文件包含路径和源码文件">4.在keil中添加头文件包含路径和源码文件 </h3>
<ul>
<li><img src="image-3.png" alt="z"></li>
<li><img src="image-4.png" alt="Alt text"></li>
</ul>
<h3 id="5在freertosconfigh中修改">5.在FreeRTOSConfig.h中修改 </h3>
<ul>
<li><img src="image-5.png" alt="Alt text"></li>
<li><img src="image-6.png" alt="Alt text"></li>
<li><img src="image-7.png" alt="Alt text"></li>
</ul>
<h3 id="6修改stm32f4xx_itc">6.修改stm32f4xx_it.c </h3>
<ul>
<li><img src="image-8.png" alt="Alt text"></li>
<li><img src="image-9.png" alt="Alt text"></li>
<li><img src="image-10.png" alt="Alt text"></li>
<li><img src="image-12.png" alt="Alt text"></li>
</ul>
<p><strong>此时进行编译,通过</strong></p>
<pre class="language-text">但在下载验证时,发现系统未正常启动,卡死在SysTick_Handle;

在谷歌上搜索,发现需修改SysTick_Handle();
</pre>
<p><img src="image-13.png" alt="Alt text"><br>
修改后下载验证成功</p>
<h1 id="第十二章">第十二章 </h1>
<pre class="language-text">任务
</pre>
<h3 id="动态创建任务">动态创建任务 </h3>
<ul>
<li>任务使用的栈和任务控制块是在创建任务时由FreeRTOS动态分配</li>
<li>内存管理在heap_4.c文件中</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">//定义任务函数</span>
<span class="token keyword keyword-void">void</span> <span class="token function">LEDblue_Task</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>parameter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">led_blue_toggle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//预先为任务栈定义一个任务控制块指针</span>
<span class="token keyword keyword-static">static</span> TaskHandle_t led1task_Handle <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token comment">//定义任务栈大小,单位为字,一个字等于4字节</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1_TASK_STACK_SIZE</span> <span class="token expression"><span class="token number">128</span></span></span>
<span class="token comment">//定义任务优先级    在FreeRTOS中数字越大优先级越高,0代表最低优先级</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1_TASK_PRIO</span> <span class="token expression"><span class="token number">2</span></span></span>
<span class="token comment">//动态任务创建</span>
<span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t<span class="token punctuation">)</span>LEDblue_Task<span class="token punctuation">,</span>
			<span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"led1_task"</span><span class="token punctuation">,</span>
			<span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span>LED1_TASK_STACK_SIZE<span class="token punctuation">,</span>
			<span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span>
			<span class="token punctuation">(</span>UBaseType_t<span class="token punctuation">)</span>LED1_TASK_PRIO<span class="token punctuation">,</span>
			<span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>led1task_Handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//启动任务调度</span>
<span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h1 id="第十三章">第十三章 </h1>
<pre class="language-text">FreeRTOS的启动流程
</pre>
<h3 id="rtos启动流程">RTOS启动流程 </h3>
<ol>
<li>"万事具备,只欠东风"</li>
</ol>
<ul>
<li>万事:硬件初始化+RTOS初始化+所有任务创建完毕</li>
<li>东风:启动任务调度</li>
</ul>
<ol start="2">
<li>"小心翼翼,十分谨慎"</li>
</ol>
<ul>
<li>main()中:硬件初始化+RTOS初始化+创建一个启动任务+启动任务调度</li>
<li>在启动任务中创建好所有任务,最后把自身删除</li>
</ul>
<p><strong>对于LiteOS和uc/OS,两种方法都可以使用,由用户选择</strong><br>
<strong>RT-Thread和FreeRTOS中则默认使用第二种</strong></p>
<ul>
<li>
<p>在任务创建中,FreeRTOS会进行一系列系统初始化,在创建任务时,会初始化堆内存;</p>
</li>
<li>
<p>开启调度器函数vTaskStartScheduler();中,会自动生成空闲任务</p>
<pre class="language-text">  当FreeRTOS启动后,就必须保证系统中每时每刻都有一个任务
  处于运行态(Running),并且空闲任务不可以
  被挂起或删除,空闲任务优先级最低;
</pre>
</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_4<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">delay_init</span><span class="token punctuation">(</span>configTICK_RATE_HZ<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">led_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t<span class="token punctuation">)</span>StartTask<span class="token punctuation">,</span>
				<span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"start_task"</span><span class="token punctuation">,</span>
				<span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span>Start_TASK_STACK_SIZE<span class="token punctuation">,</span>
				<span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span>
				<span class="token punctuation">(</span>UBaseType_t<span class="token punctuation">)</span>Start_TASK_PRIO<span class="token punctuation">,</span>
				<span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>StartTask_Handle<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">led_red_toggle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">StartTask</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>parameter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//进入临界段</span>
        <span class="token comment">//在临界段中,系统会关闭中断,所以开启任务创建前需进入临界状态,确保任务创建时不会被打断</span>
	<span class="token function">taskENTER_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t<span class="token punctuation">)</span>LEDblue_Task<span class="token punctuation">,</span>
			<span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"led1_task"</span><span class="token punctuation">,</span>
			<span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span>LED1_TASK_STACK_SIZE<span class="token punctuation">,</span>
			<span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span>
			<span class="token punctuation">(</span>UBaseType_t<span class="token punctuation">)</span>LED1_TASK_PRIO<span class="token punctuation">,</span>
			<span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>led1task_Handle<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t<span class="token punctuation">)</span>LEDgreen_Task<span class="token punctuation">,</span>
				<span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"led2_task"</span><span class="token punctuation">,</span>
				<span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span>LED2_TASK_STACK_SIZE<span class="token punctuation">,</span>
				<span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span>
				<span class="token punctuation">(</span>UBaseType_t<span class="token punctuation">)</span>LED2_TASK_PRIO<span class="token punctuation">,</span>
				<span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>led2task_Handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">vTaskDelete</span><span class="token punctuation">(</span>StartTask_Handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//退出临界段</span>
	<span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h1 id="第十四章">第十四章 </h1>
<pre class="language-text">任务管理
</pre>
<ul>
<li>当config_USETIME_SCLICING定义为1，处于就绪态的多个相同优先级的任务会以时间片切换的方式共享处理器</li>
<li>调度器会在任务切入和切出时保存上下文环境（寄存器值、栈内容）</li>
<li>每个任务需要分配自己的栈，一个系统能运行多少个任务，就取决于系统可用的SRAM</li>
<li>高优先级的任务可打断低优先级任务</li>
<li>任务不再需要时可调用FreeRTOS中删除任务API函数来显式的将其删除</li>
</ul>
<p><strong>任务的四种运行状态</strong></p>
<ol>
<li>就绪：准备运行的任务</li>
<li>运行：正在运行的任务</li>
<li>阻塞：任务当前正在等待某个时许或外部中断，包含任务挂起、任务延时、任务正在等待信号、读写队列或者等待读写时间等</li>
<li>挂起：较长时间不运行的任务可以挂起（调用vTaskSuspend）</li>
</ol>
<h3 id="常见的任务函数">常见的任务函数 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">//任务挂起函数</span>
<span class="token comment">//参数为待挂起任务的句柄，可以通过传递NULL来挂起函数本身</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vTaskSuspend</span><span class="token punctuation">(</span>TaskHandle_t xTaskToSuspend<span class="token punctuation">)</span>
<span class="token comment">//将所有任务挂起</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//任务恢复函数</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vTaskResume</span><span class="token punctuation">(</span>TaskHandle_t xTaskToResume<span class="token punctuation">)</span>
<span class="token comment">//任务恢复函数（中断）,专门用在中断服务程序中</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vTaskResumeISR</span><span class="token punctuation">(</span>TaskHandle_t xTaskToResume<span class="token punctuation">)</span>
<span class="token comment">//将所有任务恢复</span>
<span class="token keyword keyword-void">void</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//任务删除函数</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vTaskDelete</span><span class="token punctuation">(</span>TaskHandle_t xTaskToDelete<span class="token punctuation">)</span>
<span class="token comment">//任务延时函数，当调用这个函数后，任务会进入阻塞态，单位是系统时钟节拍周期</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> TickType_t xTickToDelay<span class="token punctuation">)</span>
<span class="token comment">//任务延时函数，绝对延时,当*pxPreviousWakeTime+xTimeIncrement时间到达后，立刻返回</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span>TickType_t <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> pxPreviousWakeTime<span class="token punctuation">,</span>
                                <span class="token keyword keyword-const">const</span> TickType_t xTimeIncrement<span class="token punctuation">)</span>
<span class="token keyword keyword-void">void</span> <span class="token function">DelayUntilSampleTask</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>parameter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> TickType_t xLastWakeTime<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> CountHere <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    xLastWakeTime <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xLastWakeTime<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
            任务实现功能 
         */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 
想象一下，你正在做一项需要定时完成的任务，比如每隔一段时间检查邮箱。这就像vTaskDelay()和
vTaskDelayUntil()的区别。

- vTaskDelay()就像是你设定一个闹钟，每次完成检查邮箱的任务后，你就设定一个闹钟提醒你在一
段时间后再次检查。但是，如果你在检查邮箱的过程中被打断，比如接到一个电话，那么你可能会
错过闹钟的提醒，导致下一次检查邮箱的时间推迟。
（当vTaskDelay延时的时间到了之后，如果有高优先级的任务或者中断正在执行，被延时阻塞的任务并不会马上解除阻塞）

- vTaskDelayUntil()则更像是你设定一个固定的时间，比如每天的10点检查邮箱。无论你在检查邮箱
的过程中是否被打断，你都会在下一个10点时刻再次检查邮箱。这就是所谓的“绝对延时”，它可以保
证任务以固定的时间间隔重复运行。

总的来说，vTaskDelay()是相对延时函数，适合需要固定时间间隔的延时操作；vTaskDelayUntil()是
绝对延时函数，适合实现周期性的延时操作。
 */</span>
</code></pre><h1 id="第十五章">第十五章 </h1>
<pre class="language-text">消息队列
</pre>
<ul>
<li>
<p>常用于任务间通信的数据结构，队列可以在任务与任务间，中断与任务间传递信息</p>
</li>
<li>
<p><strong>FreeRTOS中使用队列数据结构实现任务异步通讯，特性如下</strong></p>
<ol>
<li>消息支持先进先出，支持异步读写工作方式</li>
<li>读写队列均支持超时机制</li>
<li>消息支持后进先出方式排队，向队首发送消息（LIFO）</li>
<li>可以允许不同长度（不超过队列节点最大值）的任意类型消息</li>
<li>一个任务能够从任意一个消息队列接收和发送消息</li>
<li>多个任务能够从同一个消息队列接收和发送消息</li>
<li>当队列使用结束后，可以通过删除队列进行删除</li>
</ol>
</li>
<li>
<p>阻塞机制：当一个任务A对某个队列进行读操作时，有三种选择：</p>
<ol>
<li>任务A放弃读队列，去处理其他操作</li>
<li>任务A继续等待，此时进入阻塞态，A的等待时间由我们自己定义</li>
<li>任务A持续等待，进入阻塞态知道完成读取队列的消息</li>
</ol>
</li>
<li>
<p>假如有多个任务阻塞在一个消息队列中，那么这些阻塞的任务将按照任务优先级排序，优先级高的任务将优先获得队列的访问权</p>
</li>
<li>
<p>可用于发送不定长消息的场合，包括任务与任务间的消息交换</p>
</li>
</ul>
<p><strong>消息队列控制块</strong></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">QueueDefinition</span> <span class="token comment">/* The old naming convention is used to prevent breaking kernel aware debuggers. */</span>
<span class="token punctuation">{</span>
    <span class="token class-name">int8_t</span> <span class="token operator">*</span> pcHead<span class="token punctuation">;</span>           <span class="token comment">/*&lt; Points to the beginning of the queue storage area. */</span>
    <span class="token class-name">int8_t</span> <span class="token operator">*</span> pcWriteTo<span class="token punctuation">;</span>        <span class="token comment">/*&lt; Points to the free next place in the storage area.
队列消息区的下一个可用空间 */</span>

    <span class="token keyword keyword-union">union</span>
    <span class="token punctuation">{</span>
        QueuePointers_t xQueue<span class="token punctuation">;</span>     <span class="token comment">/*&lt; Data required exclusively when this structure is used as a queue. */</span>
        SemaphoreData_t xSemaphore<span class="token punctuation">;</span> <span class="token comment">/*&lt; Data required exclusively when this structure is used as a semaphore. */</span>
    <span class="token punctuation">}</span> u<span class="token punctuation">;</span>

    List_t xTasksWaitingToSend<span class="token punctuation">;</span>             <span class="token comment">/*&lt; List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */</span>
    List_t xTasksWaitingToReceive<span class="token punctuation">;</span>          <span class="token comment">/*&lt; List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */</span>

    <span class="token keyword keyword-volatile">volatile</span> UBaseType_t uxMessagesWaiting<span class="token punctuation">;</span> <span class="token comment">/*&lt; The number of items currently in the queue. */</span>
    UBaseType_t uxLength<span class="token punctuation">;</span>                   <span class="token comment">/*&lt; The length of the queue defined as the number of items it will hold, not the number of bytes. */</span>
    UBaseType_t uxItemSize<span class="token punctuation">;</span>                 <span class="token comment">/*&lt; The size of each items that the queue will hold. */</span>

    <span class="token keyword keyword-volatile">volatile</span> <span class="token class-name">int8_t</span> cRxLock<span class="token punctuation">;</span>                <span class="token comment">/*&lt; Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */</span>
    <span class="token keyword keyword-volatile">volatile</span> <span class="token class-name">int8_t</span> cTxLock<span class="token punctuation">;</span>                <span class="token comment">/*&lt; Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */</span>

    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span> <span class="token punctuation">(</span> configSUPPORT_STATIC_ALLOCATION <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> configSUPPORT_DYNAMIC_ALLOCATION <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span></span></span>
        <span class="token class-name">uint8_t</span> ucStaticallyAllocated<span class="token punctuation">;</span> <span class="token comment">/*&lt; Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span> configUSE_QUEUE_SETS <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span></span></span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">QueueDefinition</span> <span class="token operator">*</span> pxQueueSetContainer<span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span> configUSE_TRACE_FACILITY <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span></span></span>
        UBaseType_t uxQueueNumber<span class="token punctuation">;</span>
        <span class="token class-name">uint8_t</span> ucQueueType<span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span> xQUEUE<span class="token punctuation">;</span>

<span class="token comment">/* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 * name below to enable the use of older kernel aware debuggers. */</span>
<span class="token keyword keyword-typedef">typedef</span> xQUEUE Queue_t<span class="token punctuation">;</span>
</code></pre><h3 id="常用的消息队列函数">常用的消息队列函数 </h3>
<p><strong>使用队列模块的典型流程如下</strong></p>
<ul>
<li>创建消息队列</li>
<li>写队列操作</li>
<li>读队列操作</li>
<li>删除队列</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">//消息队列动态创建函数,传入队列能够存储的最大消息单元数目（队列长度）；消息单元大小，以字节为单位</span>
QueueHandle_t <span class="token function">xQueueCreate</span><span class="token punctuation">(</span>UBaseType_t uxQueueLength<span class="token punctuation">,</span>UBaseType_t uxItemSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//消息队列删除函数</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vQueueDelete</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//向消息队列发送消息函数</span>
<span class="token comment">/**
 * @brief 发送消息函数
 * 
 * @param xQueue 队列句柄
 * @param pvItemToQueue 指针，指向要发送到队尾的队列消息
 * @param xTickToWait 队列满时，等待队列空闲的最大超时时间，设置为0，直接返回
 * @return BaseType_t 成功pdTRUE,失败pdFALSE
 */</span>
BaseType_t <span class="token function">xQueueSend</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>
                      <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span>
                      TickType_t xTickToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//中断版本,BaseType_t *pvHigherPriorityTaskWoken:如果入队导致一个任务解锁，</span>
<span class="token comment">//并且解锁的任务优先级高于被中断的任务，则设置为pdTRUE，然后再中断退出前进行</span>
<span class="token comment">//一次上下文切换，去执行比唤醒任务的优先级更高的任务。可选项，可填NULL</span>
BaseType_t <span class="token function">xQueueSendFromISR</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>
                      <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span>
                      BaseType_t <span class="token operator">*</span>pvHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//发送消息到队列队首</span>
BaseType_t <span class="token function">xQueueSendToFront</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>
                      <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span>
                      TickType_t xTickToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//中断版本</span>
BaseType_t <span class="token function">xQueueSendToFrontFromISR</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>
                      <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span>
                      BaseType_t <span class="token operator">*</span>pvHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//从队列中读消息</span>
<span class="token comment">/**
 * @brief 从消息队列接收一个消息，并把接受的消息从队列中删除
 * 
 * @param xQueue 队列句柄
 * @param pvBuffer 指针，指向接收到的要保存的数据
 * @param xTicksToWait 队列为空时，阻塞超时的最大时间；设置为0，立刻返回
 * @return BaseType_t 
 */</span>
BaseType_t <span class="token function">xQueueReceive</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>
						 <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>pvBuffer<span class="token punctuation">,</span>
						 TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//中断版本</span>
BaseType_t xQueueReceiveFromISR
<span class="token comment">//接收消息，但不会删除队列中消息</span>
BaseType_t <span class="token function">xQueuePeek</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>
					  <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>pvBuffer<span class="token punctuation">,</span>
					  TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//中断版本</span>
BaseType_t xQueuePeekFromISR
</code></pre><p><strong>使用消息队列函数时，应注意以下几点</strong></p>
<ol>
<li>使用发送、接收函数时，应<strong>先创建消息队列</strong>，并根据队列句柄进行操作</li>
<li>队列读取采用<strong>FIFO</strong>，会先读取先进入队列的消息，但也支持<strong>LIFO</strong>，就会读取到最后进入的消息</li>
<li>获取队列消息时，必须定义一个存储读取数据的区域</li>
<li>无论发送还是接收，都是<strong>采用复制的方式</strong>进行</li>
<li>队列不属于任何任务</li>
</ol>
<h1 id="第十六章">第十六章 </h1>
<pre class="language-text">信号量
</pre>
<ul>
<li>信号量（Semaphore）是一种实现任务间通信的机制，可以实现任务之间同步或临界资源的互斥访问，常用于协助一组相互竞争的任务来访问临界资源。<br>
<strong>二值信号量</strong></li>
<li>二值信号量更偏向应用于同步功能（任务与任务间的同步或任务和中断间同步）<br>
<strong>计数信号量</strong></li>
<li>常将计数信号量用于事件计数与资源管理。</li>
<li>每当某个事件发生时，任务或者中断将释放一个信号量（信号量计数值加 1），当处理被事件时（一般在任务中处理），处理任务会取走该信号量（信号量计数值减 1），信号量的计数值则表示还有多少个事件没被处理。</li>
<li>计数型信号量允许多个任务对其进行操作，但限制了任务的量。<br>
<strong>互斥信号量</strong></li>
<li>特殊的二值信号量，由于其特有的优先级继承机制从而使它更适用于简单互锁，也就是保护临界资源。</li>
<li>使用信号量的很多时候是为了给临界资源建立一个标志，信号量<br>
表示了该临界资源被占用情况。<br>
<strong>递归信号量</strong></li>
<li>可以重复获取调用的</li>
<li>任务成功获取几次递归互斥量，就要返还几次</li>
</ul>
<h3 id="二值信号量">二值信号量 </h3>
<ul>
<li>大部分时间阻塞——有某些事件发生（信号量改变）——任务被唤醒去执行</li>
<li>创建信号量时，系统为创建的信号量分配内存</li>
<li>二值信号量无效时，如果有任务来获取，进入阻塞态<br>
<img src="image-14.png" alt="Alt text"></li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">//创建二值信号量</span>
QueueHandle_t <span class="token function">xSemaphoreCreateBinary</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//创建计数信号量</span>
<span class="token comment">/* 
uxMaxCount 计数信号量的最大值，当达到这个值的时候，信号量不能再被释放。
uxInitialCount 创建计数信号量的初始值。
创建成功则返回一个计数信号量句柄，不成功NULL
 */</span>
SemaphoreHandle_t <span class="token function">xSemaphoreCreateCounting</span><span class="token punctuation">(</span>UBaseType_t uxMaxCount<span class="token punctuation">,</span>
UBaseType_t uxInitialCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//信号量删除函数</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vSemaphoreDelete</span><span class="token punctuation">(</span>SemaphoreHandle_t xSemaphore<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//信号量释放函数</span>
<span class="token comment">//成功返回pdPASS，失败err_QUEUE_FULL</span>
<span class="token function">xSemaphoreGive</span><span class="token punctuation">(</span>SemaphoreHandle_t xSemaphore<span class="token punctuation">)</span>
<span class="token comment">//中断版本</span>
<span class="token function">xSemaphoreGiveFromISR</span><span class="token punctuation">(</span>SemaphoreHandle_t xSemaphore<span class="token punctuation">)</span>
<span class="token comment">//信号量获取函数</span>
<span class="token comment">//句柄；超时时间</span>
<span class="token function">xSemaphoreTake</span><span class="token punctuation">(</span>xSemaphore<span class="token punctuation">,</span> xBlockTime <span class="token punctuation">)</span>
<span class="token comment">//中断版本</span>
<span class="token function">xSemaphoreTakeFromISR</span><span class="token punctuation">(</span>SemaphoreHandle_t xSemaphore<span class="token punctuation">,</span>
<span class="token keyword keyword-signed">signed</span> BaseType_t <span class="token operator">*</span>pxHigherPriorityTaskWoken<span class="token punctuation">)</span>

</code></pre><h1 id="第十七章">第十七章 </h1>
<pre class="language-text">互斥量
</pre>
<ul>
<li>
<p>支持互斥量所有权、递归访问以及防止优先级翻转的特性，用于实现对临界资源的独占式处理。</p>
</li>
<li>
<p>互斥量更多的是用于保护资源的互锁。</p>
<p><strong>优先级继承机制</strong></p>
<ul>
<li>某个临界资源受到一个互斥量保护，如果这个资源正在被一个低优先级任务使用，那么此时的互斥量是闭锁状态，也代表了没有任务能申请到这个互斥量，如果此时一个高优先级任务想要对这个资源进行访问，去申请这个互斥量，那么高优先级任务会因为申请不到互斥量而进入阻塞态，那么系统会将现在持有该互斥量的任务的优先级临时提升到与高优先级任务的优先级相同，这个优先级提升的过程叫做优先级继承。</li>
<li>确保高优先级任务进入阻塞状态的时间尽可能短，以及将已经出现的“优先级翻转”危害降低到最小。</li>
</ul>
</li>
<li>
<p>使用互斥量的时候一定需要注意：在获得互斥量后，请尽快释放互斥量</p>
</li>
<li>
<p>用互斥量处理不同任务对临界资源的同步访问时，任务想要获得互斥量才能进行资源访问，如果一旦有任务成功获得了互斥量，则互斥量立即变为闭锁状态，此时其他任务会因为获取不到互斥量而不能访问这个资源</p>
</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">//互斥量创建函数</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">xSemaphoreCreateMutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//递归互斥量创建函数,</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">xSemaphoreCreateRecursiveMutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//互斥量删除函数</span>
<span class="token keyword keyword-void">void</span> <span class="token function">vSemaphoreDelete</span><span class="token punctuation">(</span>SemaphoreHandle_t xSemaphore<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//互斥量获取函数</span>
<span class="token function">xSemaphoreTake</span><span class="token punctuation">(</span>xSemaphore<span class="token punctuation">,</span> xBlockTime<span class="token punctuation">)</span>
<span class="token comment">//递归互斥量获取函数</span>
<span class="token function">xSemaphoreTakeRecursive</span><span class="token punctuation">(</span>xMutex<span class="token punctuation">,</span> xBlockTime<span class="token punctuation">)</span>
<span class="token comment">//互斥量释放函数</span>
<span class="token function">xSemaphoreGive</span><span class="token punctuation">(</span> xSemaphore <span class="token punctuation">)</span>
<span class="token comment">//递归互斥量释放函数 </span>
<span class="token function">xSemaphoreGiveRecursive</span><span class="token punctuation">(</span> xMutex <span class="token punctuation">)</span>

</code></pre><h1 id="事件">事件 </h1>
<ul>
<li>但事件通信只能是事件类型的通信，<strong>无数据传输</strong>。</li>
<li>任务通过“逻辑与”或“逻辑或”与一个或多个事件建立关联，形成一个事件组</li>
</ul>
<p><strong>FreeRTOS中事件的特点</strong></p>
<pre class="language-text">1. 事件只与任务相关联，事件相互独立
2. 一个 32 位的事件集合（EventBits_t 类型的变量，实际可用与表示事件的只有 24位）
3. 仅用于同步，不提供数据传输功能。
4. 事件无排队性，即多次向任务设置同一事件(如果任务还未来得及读走)，等效于只设置一次。
5. 允许多个任务对同一事件进行读写操作。
6. 支持事件等待超时机制。
</pre>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">//事件创建函数</span>
<span class="token function">xEventGroupCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//事件删除函数 </span>
<span class="token function">vEventGroupDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//事件组置位函数</span>
<span class="token comment">/* 
xEventGroup 事件句柄。
uxBitsToSet 指定事件中的事件标志位。如设置 uxBitsToSet 为 0x08 则只置位位 3，如果设置 uxBitsToSet 为 0x09 则位 3和位 0都需要被置位。
返回调用 xEventGroupSetBits() 时事件组中的值。
 */</span>
EventBits_t <span class="token function">xEventGroupSetBits</span><span class="token punctuation">(</span>EventGroupHandle_t xEventGroup<span class="token punctuation">,</span><span class="token keyword keyword-const">const</span> EventBits_t uxBitsToSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//中断版本</span>
<span class="token comment">/* 

 pxHigherPriorityTaskWoken 在使用之前必须初始化成
pdFALSE。调用 xEventGroupSetBitsFromISR()会给守护
任务发送一个消息，如果守护任务的优先级高于当前被
中断的任务的优先级的话（一般情况下都需要将守护任
务的优先级设置为所有任务中最高优先级），
pxHigherPriorityTaskWoken 会被置为 pdTRUE，然后在中
断退出前执行一次上下文切换。

 */</span>
BaseType_t <span class="token function">xEventGroupSetBitsFromISR</span><span class="token punctuation">(</span>EventGroupHandle_t xEventGroup<span class="token punctuation">,</span><span class="token keyword keyword-const">const</span> EventBits_t uxBitsToSet<span class="token punctuation">,</span>BaseType_t <span class="token operator">*</span>pxHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等待事件函数</span>
<span class="token comment">/* 
    
xEventGroup 事件句柄。
uxBitsToWaitFor 一个按位或的值，指定需要等待事件组中的哪些位置 1。
xClearOnExit pdTRUE：当 xEventGroupWaitBits()等待到满足任务唤醒的事件时，系统将清除由形参 uxBitsToWaitFor 指定的事件标志位。
             pdFALSE：不会清除由形参 uxBitsToWaitFor 指定的事件标志位。
xWaitForAllBits pdTRUE 逻辑与
                pdFALSE 逻辑或
xTicksToWait 最大超时时间，单位为系统节拍周期，常量 portTICK_PERIOD_MS用于辅助把时间转换成 MS

返回事件中的哪些事件标志位被置位，返回值很可能并不是用户指定的事件位，需要对返回值进行判断再处理

 */</span>
EventBits_t <span class="token function">xEventGroupWaitBits</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> EventGroupHandle_t xEventGroup<span class="token punctuation">,</span>
    <span class="token keyword keyword-const">const</span> EventBits_t uxBitsToWaitFor<span class="token punctuation">,</span>
    <span class="token keyword keyword-const">const</span> BaseType_t xClearOnExit<span class="token punctuation">,</span>
    <span class="token keyword keyword-const">const</span> BaseType_t xWaitForAllBits<span class="token punctuation">,</span>
    TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//清除事件组指定位</span>
<span class="token comment">//uxBitsToClear 指定事件组中的哪个位需要清除</span>
EventBits_t <span class="token function">xEventGroupClearBits</span><span class="token punctuation">(</span>EventGroupHandle_t xEventGroup<span class="token punctuation">,</span><span class="token keyword keyword-const">const</span> EventBits_t uxBitsToClear <span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><h1 id="第十九章">第十九章 </h1>
<pre class="language-text">软件定时器
</pre>
<ul>
<li>
<p>使用软件定时器时，需要我们在创建软件定时器时指定时间到达后要调用的函数，在回调函数中处理信息。</p>
</li>
<li>
<p>，回调函数也要快进快出，而且回调函数中不能有任何阻塞任务运行的情况（软件定时器回调函数的上下文环境是任务）</p>
</li>
<li>
<p>可分单次模式和周期模式</p>
</li>
<li>
<p>FreeRTOS 通过一个 prvTimerTask 任务（也叫守护任务 Daemon）管理软定时器</p>
</li>
<li>
<p>通常软件定时器以系统节拍周期为计时单位。系统节拍是系统的心跳节拍，表示系统时钟的频率，就类似人的心跳，1s 能跳动多少下，系统节拍配置为configTICK_RATE_HZ，该宏在 FreeRTOSConfig.h 中有定义，默认是 1000。</p>
<pre class="language-text">  1/1000 = 1ms
</pre>
</li>
<li>
<p>FreeRTOS 中采用两个定时器列表维护软件定时器，pxCurrentTimerList 与pxOverflowTimerList 是列表指针</p>
</li>
<li>
<p>xTimeNow为系统时间，xTickToWait = 定时时间 + 系统当前时间</p>
</li>
<li></li>
</ul>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>